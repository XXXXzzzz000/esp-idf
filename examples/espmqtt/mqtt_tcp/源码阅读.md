# æºç é˜…è¯»
ä»¥ä¸‹æ˜¯ä¸»å‡½æ•°çš„å¤„ç†æµç¨‹,ä¸»è¦æ˜¯é€šè¿‡mqttå†…éƒ¨åˆ›å»ºä»»åŠ¡,ç„¶åå°†event_handleræ³¨å†Œè¿›å».
å½“æ¥æ”¶åˆ°ä¿¡æ¯æ—¶,æ•°æ®å…ˆç»ç”±mqtté¢„å¤„ç†ç„¶åå†è°ƒç”¨event_handler

## 1.app_main
ä¸»å‡½æ•°ä¸»è¦è¿›è¡Œwifiçš„åˆå§‹åŒ–,å¹¶å¯åŠ¨mqtt
```c
void app_main()
{
    nvs_flash_init();
    //åˆå§‹åŒ–wifi
    wifi_init();
    //å¼€å§‹mqtt
    mqtt_app_start();
}
```

## 2. mqtt_app_start
mqttçš„å¯åŠ¨ä¸»è¦æ˜¯å¡«å†™ç›¸åº”çš„è¿æ¥ä¿¡æ¯,ç„¶ååˆå§‹åŒ–å®¢æˆ·ç«¯.è¿™ä¸ªå®¢æˆ·ç«¯å°±æ˜¯æˆ‘ä»¬éœ€è¦æ“ä½œçš„å¯¹è±¡,å¯åŠ¨ä¸­ä¸»è¦åšäº†
1. å¡«å†™mqtt clienté…ç½®
2. åˆå§‹åŒ–clienté…ç½®
3. å¯åŠ¨client
```c

static void mqtt_app_start(void)
{
    const esp_mqtt_client_config_t mqtt_cfg = {
        .event_handle = mqtt_event_handler,

        //ä½¿ç”¨tcpæ–¹å¼ä¼ è¾“
        .transport = MQTT_TRANSPORT_OVER_TCP,
        .host = "183.230.40.39",
        .port = 6002,

        //è®¾å¤‡id      å¯¹åº”onenetä¸­è®¾å¤‡ID
        .client_id = "26943530",
        //ç”¨æˆ·å       å¯¹åº”onenetä¸­äº§å“äº§å“ID
        .username = "124643",
        //å¯†ç         å¯¹åº”onenetä¸­è®¾å¤‡çš„é‰´æƒä¿¡æ¯ï¼ˆå³å”¯ä¸€è®¾å¤‡ç¼–å·ï¼ŒSNï¼‰
        .password = "123456789",
        // .user_context = (void *)your_context
    };

    esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_start(client);
}
```

### 2.1. esp_mqtt_client_config_t
è®¾ç½®å®¢æˆ·ç«¯çš„é…ç½®æœ‰ä»¥ä¸‹å†…å®¹
```c
typedef struct
{
    mqtt_event_callback_t event_handle;   //äº‹ä»¶å¤„ç†å¥æŸ„
    char host[MQTT_MAX_HOST_LEN];         //host
    char uri[MQTT_MAX_HOST_LEN];          //uri
    uint32_t port;                        //ç«¯å£,æ­¤å¤„æŒ‡å®šçš„ç«¯å£ä¼šè¦†ç›–æ‰uirä¸­æŒ‡å®šçš„ç«¯å£
    char client_id[MQTT_MAX_CLIENT_LEN];  //å®¢æˆ·ç«¯id é»˜è®¤çš„å®¢æˆ·ç«¯IDæ˜¯ ESP32_%CHIPID%
    char username[MQTT_MAX_USERNAME_LEN]; //ç”¨æˆ·å
    char password[MQTT_MAX_PASSWORD_LEN]; //å¯†ç 
    char lwt_topic[MQTT_MAX_LWT_TOPIC];   //lwt_topic-lwt_msg_lenæ˜¯mqtt lwté€‰é¡¹ï¼Œé»˜è®¤ä¸ºNULL
    char lwt_msg[MQTT_MAX_LWT_MSG];
    int lwt_qos;
    int lwt_retain;
    int lwt_msg_len;

    int disable_clean_session;      //mqttæ¸…ç†ä¼šè¯ï¼Œé»˜è®¤clean_sessionä¸ºtrue
    int keepalive;                  //(ä»¥ç§’ä¸ºå•ä½ï¼‰mqtt keepaliveï¼Œé»˜è®¤å€¼ä¸º120ç§’
    bool disable_auto_reconnect;    //è¿™ä¸ªmqttå®¢æˆ·ç«¯å°†é‡æ–°è¿æ¥åˆ°æœåŠ¡å™¨ï¼ˆå½“é”™è¯¯/æ–­å¼€è¿æ¥æ—¶ï¼‰ã€‚è®¾ç½®ä¸ºdisable_auto_reconnect=trueä¸ºç¦ç”¨
    void *user_context;             //å°†ç”¨æˆ·ä¸Šä¸‹æ–‡ä¼ é€’ç»™æ­¤é€‰é¡¹ï¼Œç„¶åå¯ä»¥æ¥æ”¶è¯¥ä¸Šä¸‹æ–‡ event->user_context
    int task_prio;                  //å¯¹äºMQTTä»»åŠ¡ï¼Œé»˜è®¤ä¼˜å…ˆçº§ä¸º5ï¼Œ
    int task_stack;                 //å¯¹äºMQTTä»»åŠ¡,task_stack = 6144å­—èŠ‚ï¼ˆæˆ–è€…å¯ä»¥é€šè¿‡è®¾ç½®é»˜è®¤ä»»åŠ¡å †æ ˆmake menucofigï¼‰ã€‚
    int buffer_size;                //å¯¹äºMQTTå‘é€/æ¥æ”¶ç¼“å†²åŒºï¼Œé»˜è®¤å€¼ä¸º1024
    const char *cert_pem;           //æŒ‡å‘CERTæ–‡ä»¶çš„æœåŠ¡å™¨éªŒè¯ï¼ˆä½¿ç”¨SSLï¼‰ï¼Œé»˜è®¤å€¼ä¸ºNULLï¼Œä¸éœ€è¦éªŒè¯æœåŠ¡å™¨
    esp_mqtt_transport_t transport; //è¦†ç›–URIä¼ è¾“
} esp_mqtt_client_config_t;
```
å…¶ä¸­`esp_mqtt_transport_t`åŒ…å«ä»¥ä¸‹å‡ ç§å€¼
```c
MQTT_TRANSPORT_OVER_TCPï¼šåŸºäºTCPçš„MQTTï¼Œä½¿ç”¨æ–¹æ¡ˆï¼š mqtt
MQTT_TRANSPORT_OVER_SSLï¼šé€šè¿‡SSLçš„MQTTï¼Œä½¿ç”¨æ–¹æ¡ˆï¼š mqtts
MQTT_TRANSPORT_OVER_WSï¼šåŸºäºWebsocketçš„MQTTï¼Œä½¿ç”¨schemeï¼š ws
MQTT_TRANSPORT_OVER_WSSï¼šåŸºäºWebsocket Secureçš„MQTTï¼Œä½¿ç”¨æ–¹æ¡ˆï¼š wss
```

å…³äºmqtté…ç½®çš„è¯¦ç»†å†…å®¹è¯·æŸ¥çœ‹[espmqtt](https://github.com/tuanpmt/espmqtt)

## 3. esp_mqtt_client_init(&mqtt_cfg);
åˆå§‹åŒ–clientä¸­ä¸»è¦
1. å°†configä¸­çš„é…ç½®ä¿å­˜åˆ°clientä¸­
2. å¡«å†™ç›¸åº”çš„ä¼ è¾“æ¥å£
3. åˆå§‹åŒ–ç›¸å…³çš„buffer
```c
esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config)
{
    //ç”³è¯·clientç©ºé—´
    esp_mqtt_client_handle_t client = calloc(1, sizeof(struct esp_mqtt_client));
    mem_assert(client);
    //è®¾ç½®client,å°†configå­˜å‚¨åˆ°å†…å¹¶é…ç½®ä¸€äº›é»˜è®¤è®¾ç½®
    esp_mqtt_set_config(client, config);
    //åˆå§‹åŒ–ä¼ è¾“é“¾è¡¨
    client->transport_list = transport_list_init();
    //åˆå§‹åŒ–tcp,å°†tcpé…ç½®åˆå§‹åŒ–,socket,æ¥å£ç­‰ç›¸å…³è”
    transport_handle_t tcp = transport_tcp_init();
    transport_set_default_port(tcp, MQTT_TCP_DEFAULT_PORT);
    //å°†tcpè¿æ¥æ·»åŠ è¿›ä¼ è¾“é“¾è¡¨
    transport_list_add(client->transport_list, tcp, "mqtt");
    if (config->transport == MQTT_TRANSPORT_OVER_TCP)
    {
        client->config->scheme = create_string("mqtt", 4);
    }

    if (client->config->uri)
    {
        if (esp_mqtt_client_set_uri(client, client->config->uri) != ESP_OK)
        {
            return NULL;
        }
    }

    if (client->config->scheme == NULL)
    {
        client->config->scheme = create_string("mqtt", 4);
    }
    //è®¾ç½®ä¿æŒè¿æ¥,é‡è¿æ—¶é—´
    client->keepalive_tick = platform_tick_get_ms();
    client->reconnect_tick = platform_tick_get_ms();

    int buffer_size = config->buffer_size;
    if (buffer_size <= 0)
    {
        buffer_size = MQTT_BUFFER_SIZE_BYTE;
    }
    //é…ç½®mqttçŠ¶æ€
    client->mqtt_state.in_buffer = (uint8_t *)malloc(buffer_size);
    mem_assert(client->mqtt_state.in_buffer);
    client->mqtt_state.in_buffer_length = buffer_size;
    client->mqtt_state.out_buffer = (uint8_t *)malloc(buffer_size);
    mem_assert(client->mqtt_state.out_buffer);
    client->mqtt_state.out_buffer_length = buffer_size;
    client->mqtt_state.connect_info = &client->connect_info;
    //åˆå§‹åŒ–outbox
    client->outbox = outbox_init();
    //åˆå§‹åŒ–çŠ¶æ€ä½
    client->status_bits = xEventGroupCreate();
    return client;
}

```
å…¶ä¸­ `esp_mqtt_client_handle_t`ç±»å‹çš„client ä¸»è¦åŒ…å«ä»¥ä¸‹å†…å®¹
```c
typedef struct esp_mqtt_client *esp_mqtt_client_handle_t;
struct esp_mqtt_client
{
    transport_list_handle_t transport_list; //ä¼ è¾“é“¾è¡¨
    transport_handle_t transport;           //ä¿å­˜tcpçš„socket,readç­‰æ¥å£
    mqtt_config_storage_t *config;          //ä¿å­˜çš„é…ç½®ä¿¡æ¯å¦‚ipåœ°å€ uriç­‰
    mqtt_state_t mqtt_state;                //ä¿å­˜mqttçŠ¶æ€ä¿¡æ¯,buffer,bufferé•¿åº¦ç­‰
    mqtt_connect_info_t connect_info;       //è¿æ¥ä¿¡æ¯,ç”¨æˆ·å,å¯†ç ,will_qosç­‰
    mqtt_client_state_t state;              //å®¢æˆ·ç«¯çŠ¶æ€,é”™è¯¯,æœªçŸ¥,å·²è¿æ¥,ç­‰å¾…è¶…æ—¶ç­‰
    long long keepalive_tick;
    long long reconnect_tick;
    int wait_timeout_ms;
    int auto_reconnect;
    esp_mqtt_event_t event; //mqttäº‹ä»¶ä¿¡æ¯,user_context,data,topic
    bool run;
    outbox_handle_t outbox;
    EventGroupHandle_t status_bits; //freeRTOSçš„äº‹ä»¶ç»„
};
```

## 4. esp_mqtt_client_start(client);
å¯åŠ¨mqtt clientåˆ›å»ºäº†ä¸€ä¸ªfreeRTOSçš„ä»»åŠ¡
```c
esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client)
{
    //åˆ›å»ºmqttä»»åŠ¡
    if (xTaskCreate(esp_mqtt_task, "mqtt_task", client->config->task_stack, client, client->config->task_prio, NULL) != pdTRUE)
    //æ¸…é™¤çŠ¶æ€ä½
    xEventGroupClearBits(client->status_bits, STOPPED_BIT);
    return ESP_OK;
}
```

å…¶ä¸­çš„`esp_mqtt_task`ä¸»è¦è¿›è¡Œäº†mqttæ•°æ®çš„é¢„å¤„ç†,å®Œæˆäº†mqttåè®®éƒ¨åˆ†çš„å†…å®¹,ç„¶åè°ƒç”¨è®¾ç½®çš„event_handler
```c
static void esp_mqtt_task(void *pv)
{
    esp_mqtt_client_handle_t client = (esp_mqtt_client_handle_t) pv;
    client->run = true;

    //æ ¹æ®client->config->schem ä»client->transport_listä¸­è·å–ä¼ è¾“æ¥å£eget transport by scheme
    client->transport = transport_list_get_transport(client->transport_list, client->config->scheme);


    //default port
    if (client->config->port == 0) {
        client->config->port = transport_get_default_port(client->transport);
    }
    //è®¾ç½®clientçŠ¶æ€
    client->state = MQTT_STATE_INIT;
    //æ¸…é™¤åœæ­¢ä½
    xEventGroupClearBits(client->status_bits, STOPPED_BIT);
    //clientè¿è¡Œ
    while (client->run) {
        //æ ¹æ®client->stateæ‰§è¡Œä»»åŠ¡
        switch ((int)client->state) {
            //mqttåˆå§‹åŒ–
            case MQTT_STATE_INIT:
                //æ ¹æ®clientä¿å­˜çš„ä¼ è¾“ç«¯å£,è¿æ¥ä¿¡æ¯è¿›è¡Œè¿æ¥
                if (transport_connect(client->transport,
                                      client->config->host,
                                      client->config->port,
                                      client->config->network_timeout_ms) < 0)
                //mqttè¿æ¥è¯¦è§3.2.1.1.esp_mqtt_connect
                if (esp_mqtt_connect(client, client->config->network_timeout_ms) != ESP_OK)
                //æ ¹æ®è¿æ¥ç»“æœè®¾ç½®äº‹ä»¶idå’ŒclientçŠ¶æ€
                client->event.event_id = MQTT_EVENT_CONNECTED;
                client->state = MQTT_STATE_CONNECTED;
                //æ ¹æ®äº‹ä»¶ä¿å­˜å“åº”ä¿¡æ¯åè°ƒç”¨event_handler
                esp_mqtt_dispatch_event(client);

                break;
            //mqttå·²ç»è¿æ¥
            case MQTT_STATE_CONNECTED:
                // æ¥æ”¶å¹¶å¤„ç†æ•°æ®
                if (mqtt_process_receive(client) == ESP_FAIL) {
                //åˆ¤æ–­æ˜¯å¦è¶…æ—¶
                if (platform_tick_get_ms() - client->keepalive_tick > client->connect_info.keepalive * 1000 / 2) {
                    //å‘é€pingå‘½ä»¤ä¿æŒè¿æ¥
                    if (esp_mqtt_client_ping(client) == ESP_FAIL)
                    //åˆ·æ–°æ—¶é—´
                    client->keepalive_tick = platform_tick_get_ms();
                }

                //30såˆ é™¤æ¶ˆæ¯
                outbox_delete_expired(client->outbox, platform_tick_get_ms(), OUTBOX_EXPIRED_TIMEOUT_MS);
                //æ¸…ç©ºoutbox
                outbox_cleanup(client->outbox, OUTBOX_MAX_SIZE);
                break;
            //ç­‰å¾…è¶…æ—¶äº‹ä»¶
            case MQTT_STATE_WAIT_TIMEOUT:
                //æ²¡æœ‰è®¾ç½®è‡ªåŠ¨é‡è¿,åˆ™åœæ­¢è¿è¡Œ
                if (!client->config->auto_reconnect) {
                    client->run = false;
                    break;
                }
                if (platform_tick_get_ms() - client->reconnect_tick > client->wait_timeout_ms) {
                    client->state = MQTT_STATE_INIT;
                    client->reconnect_tick = platform_tick_get_ms();
                    ESP_LOGD(TAG, "Reconnecting...");
                }
                vTaskDelay(client->wait_timeout_ms/2/portTICK_RATE_MS);
                break;
        }
    }
    transport_close(client->transport);
    xEventGroupSetBits(client->status_bits, STOPPED_BIT);

    vTaskDelete(NULL);
}
```

å…¶ä¸­çš„`esp_mqtt_connect`å®Œæˆäº†mqtt client åˆ°æœåŠ¡å™¨çš„è¿æ¥.
```c
static esp_err_t esp_mqtt_connect(esp_mqtt_client_handle_t client, int timeout_ms)
{
    int write_len, read_len, connect_rsp_code;
    //è·å–mqttè¿æ¥ä¿¡æ¯,ç”¨æˆ·å,mqtt
    mqtt_msg_init(&client->mqtt_state.mqtt_connection,
                  client->mqtt_state.out_buffer,
                  client->mqtt_state.out_buffer_length);
    //æ ¹æ®clientä¸­å¡«å†™çš„username,passwordç­‰ç”Ÿæˆmessage
    client->mqtt_state.outbound_message = mqtt_msg_connect(&client->mqtt_state.mqtt_connection,
                                          client->mqtt_state.connect_info);
    //è·å–messageç±»å‹å¹¶å­˜å‚¨(è¿˜åŸå¤´éƒ¨ä¿¡æ¯ä¸­åŒ…å«çš„åŒ…ç±»å‹)
    client->mqtt_state.pending_msg_type = mqtt_get_type(client->mqtt_state.outbound_message->data);
    client->mqtt_state.pending_msg_id = mqtt_get_id(client->mqtt_state.outbound_message->data,
                                        client->mqtt_state.outbound_message->length);
    //å‘é€ä¿¡æ¯
    write_len = transport_write(client->transport,
                                (char *)client->mqtt_state.outbound_message->data,
                                client->mqtt_state.outbound_message->length,
                                client->config->network_timeout_ms);
    //è¯»å–è¿”å›å€¼
    read_len = transport_read(client->transport,
                              (char *)client->mqtt_state.in_buffer,
                              client->mqtt_state.outbound_message->length,
                              client->config->network_timeout_ms);
    //åˆ¤æ–­è¿æ¥æ˜¯å¦æˆåŠŸ
    if (mqtt_get_type(client->mqtt_state.in_buffer) != MQTT_MSG_TYPE_CONNACK)
    //è·å–è¿”å›å€¼å¹¶æ ¹æ®è¿”å›å€¼åˆ¤æ–­é”™è¯¯ç±»å‹
    connect_rsp_code = mqtt_get_connect_return_code(client->mqtt_state.in_buffer);
    switch (connect_rsp_code)


    return ESP_OK;
}
```

## 5. esp_mqtt_client_subscribe

```c
/*
    esp_mqtt_client_handle_t client :client
    const char *topic : topic
    const char *data  : data
    int len :é•¿åº¦
    int qos :qos
    int retain :æ–°çš„è®¢é˜…ï¼ŒRETAIN=1ï¼Œå¯¹äºåŒ¹é…å·²æœ‰çš„è®¢é˜…åˆ™RETAIN = 0
 */
int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain)
{
    uint16_t pending_msg_id = 0;
    //æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦è¿æ¥
    if (client->state != MQTT_STATE_CONNECTED)
    //æ²¡æœ‰è®¾ç½®æ•°æ®é•¿åº¦åˆ™é€šè¿‡strlenè·å–å…¶é•¿åº¦
    if (len <= 0) {
        len = strlen(data);
    }
    //qos>0éœ€è¦è¿›è¡Œç‰¹æ®Šå¤„ç†
    if (qos > 0) {
        mqtt_enqueue(client);
    }
    //è·å–publishæ¶ˆæ¯
    client->mqtt_state.outbound_message = mqtt_msg_publish(&client->mqtt_state.mqtt_connection,
                                          topic, data, len,
                                          qos, retain,
                                          &pending_msg_id);
    //qos>0è·å–æ•°æ®ç±»å‹è·å–id
    if (qos > 0) {
        client->mqtt_state.pending_msg_type = mqtt_get_type(client->mqtt_state.outbound_message->data);
        client->mqtt_state.pending_msg_id = pending_msg_id;
        client->mqtt_state.pending_msg_count ++;
    }
    //å‘é€
    if (mqtt_write_data(client) != ESP_OK)
    return pending_msg_id;
}

```
å…¶ä¸­è·å–å¤„ç†åçš„publish msgä¸º
```c

mqtt_message_t* mqtt_msg_publish(mqtt_connection_t* connection, const char* topic, const char* data, int data_length, int qos, int retain, uint16_t* message_id)
{
    //åˆå§‹åŒ–msg
    init_message(connection);
    //topicä¸ºç©º
    if (topic == NULL || topic[0] == '\0')
        return fail_message(connection);
    //è¿½åŠ topic
    if (append_string(connection, topic, strlen(topic)) < 0)
        return fail_message(connection);
    //qos>0
    if (qos > 0)
        //æ·»åŠ  msg id
        if ((*message_id = append_message_id(connection, 0)) == 0)
    else
        *message_id = 0;
    //msgè¿‡é•¿
    if (connection->message.length + data_length > connection->buffer_length)
        return fail_message(connection);
    //ä¿å­˜æ•°æ®
    memcpy(connection->buffer + connection->message.length, data, data_length);
    connection->message.length += data_length;
    //æ·»åŠ å¤´éƒ¨ä¿¡æ¯
    return fini_message(connection, MQTT_MSG_TYPE_PUBLISH, 0, qos, retain);
}
```

## è°ƒè¯•ä¿¡æ¯è§£æ
```shell

I (3693) Send Data: 82 13 70 b7 00 0e 2f 32 36 39 34 32 36 37 34 2f
I (3693) Send Data: 71 6f 73 30 00
Fixed header 82 (1000 0010)
    1000ç±»å‹:SUBSCRIBE	8	å®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯	å®¢æˆ·ç«¯è®¢é˜…è¯·æ±‚
    0010ä¿ç•™
Variable header 13 (0001 0011)
    æœ€é«˜ä½ä¸º0,å•å­—èŠ‚æ§åˆ¶ å‰©ä½™0x13=19å­—èŠ‚
Payload 70 b7 00 0e 2f 32 36 39 34 32 36 37 34 2f 71 6f 73 30 00 (å…±19å­—èŠ‚)
    æŠ¥æ–‡æ ‡è¯†ç¬¦: MSB:70 LSB:b7
    æœ‰æ•ˆè½½è·: è½¬æ¢ä¸ºå­—ç¬¦åçš„å†…å®¹:/26942674/qos0
I (3693) MQTT_SAMPLE: sent subscribe successful, msg_id=28855


I (3703) Send Data: 82 13 07 54 00 0e 2f 32 36 39 34 32 36 37 34 2f
I (3713) Send Data: 71 6f 73 31 01
Fixed header 82 (1000 0010)
    1000ç±»å‹:SUBSCRIBE	8	å®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯	å®¢æˆ·ç«¯è®¢é˜…è¯·æ±‚
    0010ä¿ç•™
Variable header 13 (0001 0011)
    æœ€é«˜ä½ä¸º0,å•å­—èŠ‚æ§åˆ¶ å‰©ä½™0x13=19å­—èŠ‚
Payload 07 54 00 0e 2f 32 36 39 34 32 36 37 34 2f 71 6f 73 31 01 (å…±19å­—èŠ‚)
    æŠ¥æ–‡æ ‡è¯†ç¬¦: MSB:07 LSB:54
    æœ‰æ•ˆè½½è·: è½¬æ¢ä¸ºå­—ç¬¦åçš„å†…å®¹:/26942674/qos1
I (3713) MQTT_SAMPLE: sent subscribe successful, msg_id=1876


I (3723) Send Data: a2 12 98 a4 00 0e 2f 32 36 39 34 32 36 37 34 2f
I (3723) Send Data: 71 6f 73 31
Fixed header a2 (1010 0010)
    1010ç±»å‹:UNSUBSCRIBE	10	å®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯	å®¢æˆ·ç«¯å–æ¶ˆè®¢é˜…è¯·æ±‚
    0010ä¿ç•™
Variable header 12 (0001 0010)
    æœ€é«˜ä½ä¸º0,å•å­—èŠ‚æ§åˆ¶ å‰©ä½™0x13=18å­—èŠ‚
Payload 98 a4 00 0e 2f 32 36 39 34 32 36 37 34 2f 71 6f 73 31  (å…±18å­—èŠ‚)
    æŠ¥æ–‡æ ‡è¯†ç¬¦: MSB:98 LSB:a4
    æœ‰æ•ˆè½½è·: è½¬æ¢ä¸ºå­—ç¬¦åçš„å†…å®¹:/26942674/qos1
I (3733) MQTT_SAMPLE: sent unsubscribe successful, msg_id=39076



I (3743) Send Data: 30 14 00 0e 2f 32 36 39 34 32 36 37 34 2f 71 6f
I (3753) Send Data: 73 30 64 61 74 61
Fixed header 30 (0011 0000)
    1010ç±»å‹:PUBLISH	3	ä¸¤ä¸ªæ–¹å‘éƒ½å…è®¸	å‘å¸ƒæ¶ˆæ¯
    0010 DUP-QoS-QoS-RETAIN :
        DUP,æ§åˆ¶æŠ¥æ–‡çš„é‡å¤åˆ†å‘æ ‡å¿— 0
        QoS,PUBLISHæŠ¥æ–‡çš„æœåŠ¡è´¨é‡ç­‰çº§ 1
        RETAIN,PUBLISHæŠ¥æ–‡çš„ä¿ç•™æ ‡å¿— 0
Variable header 14 (0001 0100)
    æœ€é«˜ä½ä¸º0,å•å­—èŠ‚æ§åˆ¶ å‰©ä½™0x14=20å­—èŠ‚
Payload 00 0e 2f 32 36 39 34 32 36 37 34 2f 71 6f 73 30 64 61 74 61  (å…±20å­—èŠ‚)
    æŠ¥æ–‡æ ‡è¯†ç¬¦: MSB:00 LSB:0e
    æœ‰æ•ˆè½½è·: è½¬æ¢ä¸ºå­—ç¬¦åçš„å†…å®¹:/26942674/qos0data
I (3763) MQTT_SAMPLE: sent publish successful, msg_id=0


I (63873) Send Data: c0 00
Fixed header c0 (1100 0000)
    1010ç±»å‹:PINGREQ	12	å®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯	å¿ƒè·³è¯·æ±‚
    0000ä¿ç•™
```
